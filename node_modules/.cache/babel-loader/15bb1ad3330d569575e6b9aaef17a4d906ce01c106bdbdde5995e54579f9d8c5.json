{"ast":null,"code":"const THREE = require('three');\nvar Zlib = require('./inflate.min').Zlib;\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nmodule.exports = function () {\n  THREE.FBXLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n  Object.assign(THREE.FBXLoader.prototype, {\n    load: function (url, onLoad, onProgress, onError) {\n      var self = this;\n      var resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n      var loader = new THREE.FileLoader(this.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        try {\n          var scene = self.parse(buffer, resourceDirectory);\n          onLoad(scene);\n        } catch (error) {\n          window.setTimeout(function () {\n            if (onError) onError(error);\n            self.manager.itemError(url);\n          }, 0);\n        }\n      }, onProgress, onError);\n    },\n    parse: function (FBXBuffer, resourceDirectory) {\n      var FBXTree;\n      if (isFbxFormatBinary(FBXBuffer)) {\n        FBXTree = new BinaryParser().parse(FBXBuffer);\n      } else {\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n        if (!isFbxFormatASCII(FBXText)) {\n          throw new Error('THREE.FBXLoader: Unknown format.');\n        }\n        if (getFbxVersion(FBXText) < 7000) {\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n        }\n        FBXTree = new TextParser().parse(FBXText);\n      }\n\n      // console.log( FBXTree );\n\n      var connections = parseConnections(FBXTree);\n      var images = parseImages(FBXTree);\n      var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n      var materials = parseMaterials(FBXTree, textures, connections);\n      var deformers = parseDeformers(FBXTree, connections);\n      var geometryMap = parseGeometries(FBXTree, connections, deformers);\n      var sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);\n      return sceneGraph;\n    }\n  });\n\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  function parseConnections(FBXTree) {\n    var connectionMap = new Map();\n    if ('Connections' in FBXTree) {\n      var rawConnections = FBXTree.Connections.connections;\n      rawConnections.forEach(function (rawConnection) {\n        var fromID = rawConnection[0];\n        var toID = rawConnection[1];\n        var relationship = rawConnection[2];\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n        var parentRelationship = {\n          ID: toID,\n          relationship: relationship\n        };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n        var childRelationship = {\n          ID: fromID,\n          relationship: relationship\n        };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n    return connectionMap;\n  }\n\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  function parseImages(FBXTree) {\n    var images = {};\n    var blobs = {};\n    if ('Video' in FBXTree.Objects) {\n      var videoNodes = FBXTree.Objects.Video;\n      for (var nodeID in videoNodes) {\n        var videoNode = videoNodes[nodeID];\n        var id = parseInt(nodeID);\n        images[id] = videoNode.RelativeFilename || videoNode.Filename;\n\n        // raw image data is in videoNode.Content\n        if ('Content' in videoNode) {\n          var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n          if (arrayBufferContent || base64Content) {\n            var image = parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n    for (var id in images) {\n      var filename = images[id];\n      if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n    }\n    return images;\n  }\n\n  // Parse embedded image data in FBXTree.Video.Content\n  function parseImage(videoNode) {\n    var content = videoNode.Content;\n    var fileName = videoNode.RelativeFilename || videoNode.Filename;\n    var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n    var type;\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp';\n        break;\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg';\n        break;\n      case 'png':\n        type = 'image/png';\n        break;\n      case 'tif':\n        type = 'image/tiff';\n        break;\n      case 'tga':\n        if (typeof THREE.TGALoader !== 'function') {\n          console.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n          return;\n        } else {\n          if (THREE.Loader.Handlers.get('.tga') === null) {\n            THREE.Loader.Handlers.add(/\\.tga$/i, new THREE.TGALoader());\n          }\n          type = 'image/tga';\n          break;\n        }\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n    if (typeof content === 'string') {\n      // ASCII format\n\n      return 'data:' + type + ';base64,' + content;\n    } else {\n      // Binary Format\n\n      var array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], {\n        type: type\n      }));\n    }\n  }\n\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  function parseTextures(FBXTree, loader, images, connections) {\n    var textureMap = new Map();\n    if ('Texture' in FBXTree.Objects) {\n      var textureNodes = FBXTree.Objects.Texture;\n      for (var nodeID in textureNodes) {\n        var texture = parseTexture(textureNodes[nodeID], loader, images, connections);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n    return textureMap;\n  }\n\n  // Parse individual node in FBXTree.Objects.Texture\n  function parseTexture(textureNode, loader, images, connections) {\n    var texture = loadTexture(textureNode, loader, images, connections);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    var wrapModeU = textureNode.WrapModeU;\n    var wrapModeV = textureNode.WrapModeV;\n    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    if ('Scaling' in textureNode) {\n      var values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n    return texture;\n  }\n\n  // load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n  function loadTexture(textureNode, loader, images, connections) {\n    var fileName;\n    var currentPath = loader.path;\n    var children = connections.get(textureNode.id).children;\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID];\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        loader.setPath(undefined);\n      }\n    }\n    var texture;\n    if (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {\n      texture = THREE.Loader.Handlers.get('.tga').load(fileName);\n    } else {\n      texture = loader.load(fileName);\n    }\n    loader.setPath(currentPath);\n    return texture;\n  }\n\n  // Parse nodes in FBXTree.Objects.Material\n  function parseMaterials(FBXTree, textureMap, connections) {\n    var materialMap = new Map();\n    if ('Material' in FBXTree.Objects) {\n      var materialNodes = FBXTree.Objects.Material;\n      for (var nodeID in materialNodes) {\n        var material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n    return materialMap;\n  }\n\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  function parseMaterial(FBXTree, materialNode, textureMap, connections) {\n    var ID = materialNode.id;\n    var name = materialNode.attrName;\n    var type = materialNode.ShadingModel;\n\n    //Case where FBX wraps shading model in property object.\n    if (typeof type === 'object') {\n      type = type.value;\n    }\n\n    // Ignore unused materials which don't have any connections.\n    if (!connections.has(ID)) return null;\n    var parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);\n    var material;\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new THREE.MeshPhongMaterial();\n        break;\n      case 'lambert':\n        material = new THREE.MeshLambertMaterial();\n        break;\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new THREE.MeshPhongMaterial({\n          color: 0x3300ff\n        });\n        break;\n    }\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  }\n\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  function parseParameters(FBXTree, properties, textureMap, ID, connections) {\n    var parameters = {};\n    if (properties.BumpFactor) {\n      parameters.bumpScale = properties.BumpFactor.value;\n    }\n    if (properties.Diffuse) {\n      parameters.color = new THREE.Color().fromArray(properties.Diffuse.value);\n    } else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {\n      // The blender exporter exports diffuse here instead of in properties.Diffuse\n      parameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);\n    }\n    if (properties.DisplacementFactor) {\n      parameters.displacementScale = properties.DisplacementFactor.value;\n    }\n    if (properties.Emissive) {\n      parameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);\n    } else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {\n      // The blender exporter exports emissive color here instead of in properties.Emissive\n      parameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);\n    }\n    if (properties.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n    }\n    if (properties.Opacity) {\n      parameters.opacity = parseFloat(properties.Opacity.value);\n    }\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true;\n    }\n    if (properties.ReflectionFactor) {\n      parameters.reflectivity = properties.ReflectionFactor.value;\n    }\n    if (properties.Shininess) {\n      parameters.shininess = properties.Shininess.value;\n    }\n    if (properties.Specular) {\n      parameters.specular = new THREE.Color().fromArray(properties.Specular.value);\n    } else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in properties.Specular\n      parameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);\n    }\n    connections.get(ID).children.forEach(function (child) {\n      var type = child.relationship;\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = textureMap.get(child.ID);\n          break;\n        case 'DiffuseColor':\n          parameters.map = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n        case 'DisplacementColor':\n          parameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n        case 'EmissiveColor':\n          parameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n        case 'NormalMap':\n          parameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n        case 'ReflectionColor':\n          parameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n          break;\n        case 'SpecularColor':\n          parameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n        case 'TransparentColor':\n          parameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.transparent = true;\n          break;\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n        case 'SpecularFactor': // AKA specularLevel\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n          break;\n      }\n    });\n    return parameters;\n  }\n\n  // get a texture from the textureMap for use by a material.\n  function getTexture(FBXTree, textureMap, id, connections) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n      id = connections.get(id).children[0].ID;\n    }\n    return textureMap.get(id);\n  }\n\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  function parseDeformers(FBXTree, connections) {\n    var skeletons = {};\n    var morphTargets = {};\n    if ('Deformer' in FBXTree.Objects) {\n      var DeformerNodes = FBXTree.Objects.Deformer;\n      for (var nodeID in DeformerNodes) {\n        var deformerNode = DeformerNodes[nodeID];\n        var relationships = connections.get(parseInt(nodeID));\n        if (deformerNode.attrType === 'Skin') {\n          var skeleton = parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === 'BlendShape') {\n          var morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);\n          morphTarget.id = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n          morphTarget.parentGeoID = relationships.parents[0].ID;\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets\n    };\n  }\n\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  function parseSkeleton(connections, deformerNodes) {\n    var rawBones = [];\n    connections.children.forEach(function (child) {\n      var boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== 'Cluster') return;\n      var rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transform: new THREE.Matrix4().fromArray(boneNode.Transform.a),\n        transformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),\n        linkMode: boneNode.Mode\n      };\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones: rawBones,\n      bones: []\n    };\n  }\n\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  function parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {\n    var rawMorphTargets = [];\n    for (var i = 0; i < relationships.children.length; i++) {\n      if (i === 8) {\n        console.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');\n        break;\n      }\n      var child = relationships.children[i];\n      var morphTargetNode = deformerNodes[child.ID];\n      var rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n      var targetRelationships = connections.get(parseInt(child.ID));\n      targetRelationships.children.forEach(function (child) {\n        if (child.relationship === 'DeformPercent') {\n          // TODO: animation of morph targets is currently unsupported\n          rawMorphTarget.weightCurveID = child.ID;\n          // weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n        } else {\n          rawMorphTarget.geoID = child.ID;\n          // morphGeo = FBXTree.Objects.Geometry[ geoID ];\n        }\n      });\n      rawMorphTargets.push(rawMorphTarget);\n    }\n    return rawMorphTargets;\n  }\n\n  // Parse nodes in FBXTree.Objects.Geometry\n  function parseGeometries(FBXTree, connections, deformers) {\n    var geometryMap = new Map();\n    if ('Geometry' in FBXTree.Objects) {\n      var geoNodes = FBXTree.Objects.Geometry;\n      for (var nodeID in geoNodes) {\n        var relationships = connections.get(parseInt(nodeID));\n        var geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n    return geometryMap;\n  }\n\n  // Parse single node in FBXTree.Objects.Geometry\n  function parseGeometry(FBXTree, relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return parseMeshGeometry(FBXTree, relationships, geoNode, deformers);\n        break;\n      case 'NurbsCurve':\n        return parseNurbsGeometry(geoNode);\n        break;\n    }\n  }\n\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  function parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {\n    var skeletons = deformers.skeletons;\n    var morphTargets = deformers.morphTargets;\n    var modelNodes = relationships.parents.map(function (parent) {\n      return FBXTree.Objects.Model[parent.ID];\n    });\n\n    // don't create geometry if it is not associated with any models\n    if (modelNodes.length === 0) return;\n    var skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n      return skeleton;\n    }, null);\n    var morphTarget = relationships.children.reduce(function (morphTarget, child) {\n      if (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n      return morphTarget;\n    }, null);\n    var preTransform = new THREE.Matrix4();\n\n    // TODO: if there is more than one model associated with the geometry, AND the models have\n    // different geometric transforms, then this will cause problems\n    // if ( modelNodes.length > 1 ) { }\n\n    // For now just assume one model and get the preRotations from that\n    var modelNode = modelNodes[0];\n    if ('GeometricRotation' in modelNode) {\n      var array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      preTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));\n    }\n    if ('GeometricTranslation' in modelNode) {\n      preTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));\n    }\n    if ('GeometricScaling' in modelNode) {\n      preTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));\n    }\n    return genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);\n  }\n\n  // Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n  function genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {\n    var geo = new THREE.BufferGeometry();\n    if (geoNode.attrName) geo.name = geoNode.attrName;\n    var geoInfo = getGeoInfo(geoNode, skeleton);\n    var buffers = genBuffers(geoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n    preTransform.applyToBufferAttribute(positionAttribute);\n    geo.addAttribute('position', positionAttribute);\n    if (buffers.colors.length > 0) {\n      geo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n    }\n    if (skeleton) {\n      geo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4));\n\n      // used later to bind the skeleton to the model\n      geo.FBX_Deformer = skeleton;\n    }\n    if (buffers.normal.length > 0) {\n      var normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n      normalMatrix.applyToBufferAttribute(normalAttribute);\n      geo.addAttribute('normal', normalAttribute);\n    }\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      // subsequent uv buffers are called 'uv1', 'uv2', ...\n      var name = 'uv' + (i + 1).toString();\n\n      // the first uv buffer is just called 'uv'\n      if (i === 0) {\n        name = 'uv';\n      }\n      geo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      var prevMaterialIndex = buffers.materialIndex[0];\n      var startIndex = 0;\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      });\n\n      // the loop above doesn't add the last group, do that here.\n      if (geo.groups.length > 0) {\n        var lastGroup = geo.groups[geo.groups.length - 1];\n        var lastIndex = lastGroup.start + lastGroup.count;\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      }\n\n      // case where there are multiple materials but the whole geometry is only\n      // using one of them\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n    addMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);\n    return geo;\n  }\n  function getGeoInfo(geoNode, skeleton) {\n    var geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = getColors(geoNode.LayerElementColor[0]);\n    }\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);\n    }\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);\n    }\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      var i = 0;\n      while (geoNode.LayerElementUV[i]) {\n        geoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));\n        i++;\n      }\n    }\n    geoInfo.weightTable = {};\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n    return geoInfo;\n  }\n  function genBuffers(geoInfo) {\n    var buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    var polygonIndex = 0;\n    var faceLength = 0;\n    var displayedWeightsWarning = false;\n\n    // these will hold data for a single face\n    var facePositionIndexes = [];\n    var faceNormals = [];\n    var faceColors = [];\n    var faceUVs = [];\n    var faceWeights = [];\n    var faceWeightIndices = [];\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      var endOfFace = false;\n\n      // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n        endOfFace = true;\n      }\n      var weightIndices = [];\n      var weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n      if (geoInfo.color) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n            displayedWeightsWarning = true;\n          }\n          var wIndex = [0, 0, 0, 0];\n          var Weight = [0, 0, 0, 0];\n          weights.forEach(function (weight, weightIndex) {\n            var currentWeight = weight;\n            var currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                var tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        }\n\n        // if the weight array is shorter than 4 pad with 0s\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n        for (var i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n      if (geoInfo.normal) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = [];\n          }\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n      faceLength++;\n      if (endOfFace) {\n        genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n        polygonIndex++;\n        faceLength = 0;\n\n        // reset arrays for the next face\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  }\n\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    for (var i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0]);\n        buffers.vertexWeights.push(faceWeights[1]);\n        buffers.vertexWeights.push(faceWeights[2]);\n        buffers.vertexWeights.push(faceWeights[3]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i * 4]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[0]);\n        buffers.weightsIndices.push(faceWeightIndices[1]);\n        buffers.weightsIndices.push(faceWeightIndices[2]);\n        buffers.weightsIndices.push(faceWeightIndices[3]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n      }\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0]);\n        buffers.colors.push(faceColors[1]);\n        buffers.colors.push(faceColors[2]);\n        buffers.colors.push(faceColors[(i - 1) * 3]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n        buffers.colors.push(faceColors[i * 3]);\n        buffers.colors.push(faceColors[i * 3 + 1]);\n        buffers.colors.push(faceColors[i * 3 + 2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0]);\n        buffers.normal.push(faceNormals[1]);\n        buffers.normal.push(faceNormals[2]);\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n        buffers.normal.push(faceNormals[i * 3]);\n        buffers.normal.push(faceNormals[i * 3 + 1]);\n        buffers.normal.push(faceNormals[i * 3 + 2]);\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][0]);\n          buffers.uvs[j].push(faceUVs[j][1]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n        });\n      }\n    }\n  }\n  function addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {\n    if (morphTarget === null) return;\n    parentGeo.morphAttributes.position = [];\n    parentGeo.morphAttributes.normal = [];\n    morphTarget.rawTargets.forEach(function (rawTarget) {\n      var morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];\n      if (morphGeoNode !== undefined) {\n        genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);\n      }\n    });\n  }\n\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {\n    var morphGeo = new THREE.BufferGeometry();\n    if (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n    var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n\n    // make a copy of the parent's vertex positions\n    var vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n    var morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n    var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n    for (var i = 0; i < indices.length; i++) {\n      var morphIndex = indices[i] * 3;\n\n      // FBX format uses blend shapes rather than morph targets. This can be converted\n      // by additively combining the blend shape positions with the original geometry's positions\n      vertexPositions[morphIndex] += morphPositions[i * 3];\n      vertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n      vertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n    }\n\n    // TODO: add morph normal support\n    var morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: vertexPositions\n    };\n    var morphBuffers = genBuffers(morphGeoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = morphGeoNode.attrName;\n    preTransform.applyToBufferAttribute(positionAttribute);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  }\n\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  function getNormals(NormalNode) {\n    var mappingType = NormalNode.MappingInformationType;\n    var referenceType = NormalNode.ReferenceInformationType;\n    var buffer = NormalNode.Normals.a;\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  function getUVs(UVNode) {\n    var mappingType = UVNode.MappingInformationType;\n    var referenceType = UVNode.ReferenceInformationType;\n    var buffer = UVNode.UV.a;\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  function getColors(ColorNode) {\n    var mappingType = ColorNode.MappingInformationType;\n    var referenceType = ColorNode.ReferenceInformationType;\n    var buffer = ColorNode.Colors.a;\n    var indexBuffer = [];\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  function getMaterials(MaterialNode) {\n    var mappingType = MaterialNode.MappingInformationType;\n    var referenceType = MaterialNode.ReferenceInformationType;\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n    }\n    var materialIndexBuffer = MaterialNode.Materials.a;\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    var materialIndices = [];\n    for (var i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n  var dataArray = [];\n  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n    var index;\n    switch (infoObject.mappingType) {\n      case 'ByPolygonVertex':\n        index = polygonVertexIndex;\n        break;\n      case 'ByPolygon':\n        index = polygonIndex;\n        break;\n      case 'ByVertice':\n        index = vertexIndex;\n        break;\n      case 'AllSame':\n        index = infoObject.indices[0];\n        break;\n      default:\n        console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n    }\n    if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n    var from = index * infoObject.dataSize;\n    var to = from + infoObject.dataSize;\n    return slice(dataArray, infoObject.buffer, from, to);\n  }\n\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  function parseNurbsGeometry(geoNode) {\n    if (THREE.NURBSCurve === undefined) {\n      console.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n      return new THREE.BufferGeometry();\n    }\n    var order = parseInt(geoNode.Order);\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n      return new THREE.BufferGeometry();\n    }\n    var degree = order - 1;\n    var knots = geoNode.KnotVector.a;\n    var controlPoints = [];\n    var pointsValues = geoNode.Points.a;\n    for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n    }\n    var startKnot, endKnot;\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n      for (var i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n    var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    var vertices = curve.getPoints(controlPoints.length * 7);\n    var positions = new Float32Array(vertices.length * 3);\n    vertices.forEach(function (vertex, i) {\n      vertex.toArray(positions, i * 3);\n    });\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n    return geometry;\n  }\n\n  // create the main THREE.Group() to be returned by the loader\n  function parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {\n    var sceneGraph = new THREE.Group();\n    var modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);\n    var modelNodes = FBXTree.Objects.Model;\n    modelMap.forEach(function (model) {\n      var modelNode = modelNodes[model.ID];\n      setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);\n      var parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function (connection) {\n        var parent = modelMap.get(connection.ID);\n        if (parent !== undefined) parent.add(model);\n      });\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);\n    addAnimations(FBXTree, connections, sceneGraph);\n    createAmbientLight(FBXTree, sceneGraph);\n    return sceneGraph;\n  }\n\n  // parse nodes in FBXTree.Objects.Model\n  function parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {\n    var modelMap = new Map();\n    var modelNodes = FBXTree.Objects.Model;\n    for (var nodeID in modelNodes) {\n      var id = parseInt(nodeID);\n      var node = modelNodes[nodeID];\n      var relationships = connections.get(id);\n      var model = buildSkeleton(relationships, skeletons, id, node.attrName);\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = createCamera(FBXTree, relationships);\n            break;\n          case 'Light':\n            model = createLight(FBXTree, relationships);\n            break;\n          case 'Mesh':\n            model = createMesh(FBXTree, relationships, geometryMap, materialMap);\n            break;\n          case 'NurbsCurve':\n            model = createCurve(relationships, geometryMap);\n            break;\n          case 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n          case 'Null':\n          default:\n            model = new THREE.Group();\n            break;\n        }\n        model.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n        model.ID = id;\n      }\n      setModelTransforms(FBXTree, model, node);\n      modelMap.set(id, model);\n    }\n    return modelMap;\n  }\n  function buildSkeleton(relationships, skeletons, id, name) {\n    var bone = null;\n    relationships.parents.forEach(function (parent) {\n      for (var ID in skeletons) {\n        var skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            var subBone = bone;\n            bone = new THREE.Bone();\n            bone.matrixWorld.copy(rawBone.transformLink);\n\n            // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n            bone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n            bone.ID = id;\n            skeleton.bones[i] = bone;\n\n            // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  }\n\n  // create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n  function createCamera(FBXTree, relationships) {\n    var model;\n    var cameraAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n      if (attr !== undefined) {\n        cameraAttribute = attr;\n      }\n    });\n    if (cameraAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type = 0;\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n      var nearClippingPlane = 1;\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n      }\n      var farClippingPlane = 1000;\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n      }\n      var width = window.innerWidth;\n      var height = window.innerHeight;\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n      var aspect = width / height;\n      var fov = 45;\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value;\n      }\n      var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n      switch (type) {\n        case 0:\n          // Perspective\n          model = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null) model.setFocalLength(focalLength);\n          break;\n        case 1:\n          // Orthographic\n          model = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n          break;\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n          model = new THREE.Object3D();\n          break;\n      }\n    }\n    return model;\n  }\n\n  // Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n  function createLight(FBXTree, relationships) {\n    var model;\n    var lightAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n      if (attr !== undefined) {\n        lightAttribute = attr;\n      }\n    });\n    if (lightAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type;\n\n      // LightType can be undefined for Point lights\n      if (lightAttribute.LightType === undefined) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n      var color = 0xffffff;\n      if (lightAttribute.Color !== undefined) {\n        color = new THREE.Color().fromArray(lightAttribute.Color.value);\n      }\n      var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n\n      // light disabled\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n      var distance = 0;\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      }\n\n      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n      var decay = 1;\n      switch (type) {\n        case 0:\n          // Point\n          model = new THREE.PointLight(color, intensity, distance, decay);\n          break;\n        case 1:\n          // Directional\n          model = new THREE.DirectionalLight(color, intensity);\n          break;\n        case 2:\n          // Spot\n          var angle = Math.PI / 3;\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n          }\n          var penumbra = 0;\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n          model = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n        default:\n          console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n          model = new THREE.PointLight(color, intensity);\n          break;\n      }\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n    return model;\n  }\n  function createMesh(FBXTree, relationships, geometryMap, materialMap) {\n    var model;\n    var geometry = null;\n    var material = null;\n    var materials = [];\n\n    // get geometry and materials(s) from connections\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new THREE.MeshPhongMaterial({\n        color: 0xcccccc\n      });\n      materials.push(material);\n    }\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = THREE.VertexColors;\n      });\n    }\n    if (geometry.FBX_Deformer) {\n      materials.forEach(function (material) {\n        material.skinning = true;\n      });\n      model = new THREE.SkinnedMesh(geometry, material);\n    } else {\n      model = new THREE.Mesh(geometry, material);\n    }\n    return model;\n  }\n  function createCurve(relationships, geometryMap) {\n    var geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n      return geo;\n    }, null);\n\n    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n    var material = new THREE.LineBasicMaterial({\n      color: 0x3300ff,\n      linewidth: 1\n    });\n    return new THREE.Line(geometry, material);\n  }\n\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  function createAmbientLight(FBXTree, sceneGraph) {\n    if ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {\n      var ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n      var r = ambientColor[0];\n      var g = ambientColor[1];\n      var b = ambientColor[2];\n      if (r !== 0 || g !== 0 || b !== 0) {\n        var color = new THREE.Color(r, g, b);\n        sceneGraph.add(new THREE.AmbientLight(color, 1));\n      }\n    }\n  }\n  function setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {\n    if ('LookAtProperty' in modelNode) {\n      var children = connections.get(model.ID).children;\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          var lookAtTarget = FBXTree.Objects.Model[child.ID];\n          if ('Lcl_Translation' in lookAtTarget) {\n            var pos = lookAtTarget.Lcl_Translation.value;\n\n            // DirectionalLight, SpotLight\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              // Cameras and other Object3Ds\n\n              model.lookAt(new THREE.Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  }\n\n  // parse the model node for transform details and apply them to the model\n  function setModelTransforms(FBXTree, model, modelNode) {\n    // http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n    if ('RotationOrder' in modelNode) {\n      var enums = ['XYZ',\n      // default\n      'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];\n      var value = parseInt(modelNode.RotationOrder.value, 10);\n      if (value > 0 && value < 6) {\n        // model.rotation.order = enums[ value ];\n\n        // Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n        console.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);\n      } else if (value === 6) {\n        console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n      }\n    }\n    if ('Lcl_Translation' in modelNode) {\n      model.position.fromArray(modelNode.Lcl_Translation.value);\n    }\n    if ('Lcl_Rotation' in modelNode) {\n      var rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);\n      rotation.push('ZYX');\n      model.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));\n    }\n    if ('Lcl_Scaling' in modelNode) {\n      model.scale.fromArray(modelNode.Lcl_Scaling.value);\n    }\n    if ('PreRotation' in modelNode) {\n      var array = modelNode.PreRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      var preRotations = new THREE.Euler().fromArray(array);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n      model.quaternion.premultiply(preRotations);\n    }\n  }\n  function bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {\n    var bindMatrices = parsePoseNodes(FBXTree);\n    for (var ID in skeletons) {\n      var skeleton = skeletons[ID];\n      var parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          var geoID = parent.ID;\n          var geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              var model = modelMap.get(geoConnParent.ID);\n              model.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n  function parsePoseNodes(FBXTree) {\n    var bindMatrices = {};\n    if ('Pose' in FBXTree.Objects) {\n      var BindPoseNode = FBXTree.Objects.Pose;\n      for (var nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose') {\n          var poseNodes = BindPoseNode[nodeID].PoseNode;\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n    return bindMatrices;\n  }\n  function parseAnimations(FBXTree, connections) {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (FBXTree.Objects.AnimationCurve === undefined) return undefined;\n    var curveNodesMap = parseAnimationCurveNodes(FBXTree);\n    parseAnimationCurves(FBXTree, connections, curveNodesMap);\n    var layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);\n    var rawClips = parseAnimStacks(FBXTree, connections, layersMap);\n    return rawClips;\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  function parseAnimationCurveNodes(FBXTree) {\n    var rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n    var curveNodesMap = new Map();\n    for (var nodeID in rawCurveNodes) {\n      var rawCurveNode = rawCurveNodes[nodeID];\n      if (rawCurveNode.attrName.match(/S|R|T/) !== null) {\n        var curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n    return curveNodesMap;\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  function parseAnimationCurves(FBXTree, connections, curveNodesMap) {\n    var rawCurves = FBXTree.Objects.AnimationCurve;\n    for (var nodeID in rawCurves) {\n      var animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      var relationships = connections.get(animationCurve.id);\n      if (relationships !== undefined) {\n        var animationCurveID = relationships.parents[0].ID;\n        var animationCurveRelationship = relationships.parents[0].relationship;\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n        }\n      }\n    }\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  function parseAnimationLayers(FBXTree, connections, curveNodesMap) {\n    var rawLayers = FBXTree.Objects.AnimationLayer;\n    var layersMap = new Map();\n    for (var nodeID in rawLayers) {\n      var layerCurveNodes = [];\n      var connection = connections.get(parseInt(nodeID));\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        var children = connection.children;\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            var curveNode = curveNodesMap.get(child.ID);\n\n            // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n            if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                var modelID;\n                connections.get(child.ID).parents.forEach(function (parent) {\n                  if (parent.relationship !== undefined) modelID = parent.ID;\n                });\n                var rawModel = FBXTree.Objects.Model[modelID.toString()];\n                var node = {\n                  modelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n                  initialPosition: [0, 0, 0],\n                  initialRotation: [0, 0, 0],\n                  initialScale: [1, 1, 1]\n                };\n                if ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;\n                if ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;\n                if ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value;\n\n                // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                // animation value as well\n                if ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;\n                layerCurveNodes[i] = node;\n              }\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n    return layersMap;\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n  function parseAnimStacks(FBXTree, connections, layersMap) {\n    var rawStacks = FBXTree.Objects.AnimationStack;\n\n    // connect the stacks (clips) up to the layers\n    var rawClips = {};\n    for (var nodeID in rawStacks) {\n      var children = connections.get(parseInt(nodeID)).children;\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n      }\n      var layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer\n      };\n    }\n    return rawClips;\n  }\n\n  // take raw animation data from parseAnimations and connect it up to the loaded models\n  function addAnimations(FBXTree, connections, sceneGraph) {\n    sceneGraph.animations = [];\n    var rawClips = parseAnimations(FBXTree, connections);\n    if (rawClips === undefined) return;\n    for (var key in rawClips) {\n      var rawClip = rawClips[key];\n      var clip = addClip(rawClip);\n      sceneGraph.animations.push(clip);\n    }\n  }\n  function addClip(rawClip) {\n    var tracks = [];\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(generateTracks(rawTracks));\n    });\n    return new THREE.AnimationClip(rawClip.name, -1, tracks);\n  }\n  function generateTracks(rawTracks) {\n    var tracks = [];\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      var positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');\n      if (positionTrack !== undefined) tracks.push(positionTrack);\n    }\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      var rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);\n      if (rotationTrack !== undefined) tracks.push(rotationTrack);\n    }\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      var scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');\n      if (scaleTrack !== undefined) tracks.push(scaleTrack);\n    }\n    return tracks;\n  }\n  function generateVectorTrack(modelName, curves, initialValue, type) {\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n    return new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n  }\n  function generateRotationTrack(modelName, curves, initialValue, preRotations) {\n    if (curves.x !== undefined) {\n      interpolateRotations(curves.x);\n      curves.x.values = curves.x.values.map(THREE.Math.degToRad);\n    }\n    if (curves.y !== undefined) {\n      interpolateRotations(curves.y);\n      curves.y.values = curves.y.values.map(THREE.Math.degToRad);\n    }\n    if (curves.z !== undefined) {\n      interpolateRotations(curves.z);\n      curves.z.values = curves.z.values.map(THREE.Math.degToRad);\n    }\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n    if (preRotations !== undefined) {\n      preRotations = preRotations.map(THREE.Math.degToRad);\n      preRotations.push('ZYX');\n      preRotations = new THREE.Euler().fromArray(preRotations);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n    }\n    var quaternion = new THREE.Quaternion();\n    var euler = new THREE.Euler();\n    var quaternionValues = [];\n    for (var i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], 'ZYX');\n      quaternion.setFromEuler(euler);\n      if (preRotations !== undefined) quaternion.premultiply(preRotations);\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n    return new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n  }\n  function getKeyframeTrackValues(times, curves, initialValue) {\n    var prevValue = initialValue;\n    var values = [];\n    var xIndex = -1;\n    var yIndex = -1;\n    var zIndex = -1;\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\n      if (curves.z) zIndex = curves.z.times.indexOf(time);\n\n      // if there is an x value defined for this frame, use that\n      if (xIndex !== -1) {\n        var xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0]);\n      }\n      if (yIndex !== -1) {\n        var yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n      if (zIndex !== -1) {\n        var zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  }\n\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  function getTimesForAllAxes(curves) {\n    var times = [];\n\n    // first join together the times for each axis, if defined\n    if (curves.x !== undefined) times = times.concat(curves.x.times);\n    if (curves.y !== undefined) times = times.concat(curves.y.times);\n    if (curves.z !== undefined) times = times.concat(curves.z.times);\n\n    // then sort them and remove duplicates\n    times = times.sort(function (a, b) {\n      return a - b;\n    }).filter(function (elem, index, array) {\n      return array.indexOf(elem) == index;\n    });\n    return times;\n  }\n\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  function interpolateRotations(curve) {\n    for (var i = 1; i < curve.values.length; i++) {\n      var initialValue = curve.values[i - 1];\n      var valuesSpan = curve.values[i] - initialValue;\n      var absoluteSpan = Math.abs(valuesSpan);\n      if (absoluteSpan >= 180) {\n        var numSubIntervals = absoluteSpan / 180;\n        var step = valuesSpan / numSubIntervals;\n        var nextValue = initialValue + step;\n        var initialTime = curve.times[i - 1];\n        var timeSpan = curve.times[i] - initialTime;\n        var interval = timeSpan / numSubIntervals;\n        var nextTime = initialTime + interval;\n        var interpolatedTimes = [];\n        var interpolatedValues = [];\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime);\n          nextTime += interval;\n          interpolatedValues.push(nextValue);\n          nextValue += step;\n        }\n        curve.times = inject(curve.times, i, interpolatedTimes);\n        curve.values = inject(curve.values, i, interpolatedValues);\n      }\n    }\n  }\n\n  // parse an FBX file in ASCII format\n  function TextParser() {}\n  Object.assign(TextParser.prototype, {\n    getPrevNode: function () {\n      return this.nodeStack[this.currentIndent - 2];\n    },\n    getCurrentNode: function () {\n      return this.nodeStack[this.currentIndent - 1];\n    },\n    getCurrentProp: function () {\n      return this.currentProp;\n    },\n    pushStack: function (node) {\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n    },\n    popStack: function () {\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n    },\n    setCurrentProp: function (val, name) {\n      this.currentProp = val;\n      this.currentPropName = name;\n    },\n    parse: function (text) {\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n      var self = this;\n      var split = text.split('\\n');\n      split.forEach(function (line, i) {\n        var matchComment = line.match(/^[\\s\\t]*;/);\n        var matchEmpty = line.match(/^[\\s\\t]*$/);\n        if (matchComment || matchEmpty) return;\n        var matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n        var matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n        var matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n        if (matchBeginning) {\n          self.parseNodeBegin(line, matchBeginning);\n        } else if (matchProperty) {\n          self.parseNodeProperty(line, matchProperty, split[++i]);\n        } else if (matchEnd) {\n          self.popStack();\n        } else if (line.match(/^[^\\s\\t}]/)) {\n          // large arrays are split over multiple lines terminated with a ',' character\n          // if this is encountered the line needs to be joined to the previous line\n          self.parseNodePropertyContinued(line);\n        }\n      });\n      return this.allNodes;\n    },\n    parseNodeBegin: function (line, property) {\n      var nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n      var nodeAttrs = property[2].split(',').map(function (attr) {\n        return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n      });\n      var node = {\n        name: nodeName\n      };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode();\n\n      // a top node\n      if (this.currentIndent === 0) {\n        this.allNodes.add(nodeName, node);\n      } else {\n        // a subnode\n\n        // if the subnode already exists, append it\n        if (nodeName in currentNode) {\n          // special case Pose needs PoseNodes as an array\n          if (nodeName === 'PoseNode') {\n            currentNode.PoseNode.push(node);\n          } else if (currentNode[nodeName].id !== undefined) {\n            currentNode[nodeName] = {};\n            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n          }\n          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n        } else if (typeof attrs.id === 'number') {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][attrs.id] = node;\n        } else if (nodeName !== 'Properties70') {\n          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n        }\n      }\n      if (typeof attrs.id === 'number') node.id = attrs.id;\n      if (attrs.name !== '') node.attrName = attrs.name;\n      if (attrs.type !== '') node.attrType = attrs.type;\n      this.pushStack(node);\n    },\n    parseNodeAttr: function (attrs) {\n      var id = attrs[0];\n      if (attrs[0] !== '') {\n        id = parseInt(attrs[0]);\n        if (isNaN(id)) {\n          id = attrs[0];\n        }\n      }\n      var name = '',\n        type = '';\n      if (attrs.length > 1) {\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n      }\n      return {\n        id: id,\n        name: name,\n        type: type\n      };\n    },\n    parseNodeProperty: function (line, property, contentLine) {\n      var propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n      var propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim();\n\n      // for special case: base64 image data follows \"Content: ,\" line\n      //\tContent: ,\n      //\t \"/9j/4RDaRXhpZgAATU0A...\"\n      if (propName === 'Content' && propValue === ',') {\n        propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n      }\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name;\n      if (parentName === 'Properties70') {\n        this.parseNodeSpecialProperty(line, propName, propValue);\n        return;\n      }\n\n      // Connections\n      if (propName === 'C') {\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n        var rest = propValue.split(',').slice(3);\n        rest = rest.map(function (elem) {\n          return elem.trim().replace(/^\"/, '');\n        });\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n        if (currentNode[propName] === undefined) {\n          currentNode[propName] = [];\n        }\n      }\n\n      // Node\n      if (propName === 'Node') currentNode.id = propValue;\n\n      // connections\n      if (propName in currentNode && Array.isArray(currentNode[propName])) {\n        currentNode[propName].push(propValue);\n      } else {\n        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n      }\n      this.setCurrentProp(currentNode, propName);\n\n      // convert string to array, unless it ends in ',' in which case more will be added to it\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(propValue);\n      }\n    },\n    parseNodePropertyContinued: function (line) {\n      var currentNode = this.getCurrentNode();\n      currentNode.a += line;\n\n      // if the line doesn't end in ',' we have reached the end of the property value\n      // so convert the string to an array\n      if (line.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(currentNode.a);\n      }\n    },\n    // parse \"Property70\"\n    parseNodeSpecialProperty: function (line, propName, propValue) {\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",').map(function (prop) {\n        return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      });\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4];\n\n      // cast values where needed, otherwise leave as strings\n      switch (innerPropType1) {\n        case 'int':\n        case 'enum':\n        case 'bool':\n        case 'ULongLong':\n        case 'double':\n        case 'Number':\n        case 'FieldOfView':\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n        case 'Color':\n        case 'ColorRGB':\n        case 'Vector3D':\n        case 'Lcl_Translation':\n        case 'Lcl_Rotation':\n        case 'Lcl_Scaling':\n          innerPropValue = parseNumberArray(innerPropValue);\n          break;\n      }\n\n      // CAUTION: these props must append to parent's parent\n      this.getPrevNode()[innerPropName] = {\n        'type': innerPropType1,\n        'type2': innerPropType2,\n        'flag': innerPropFlag,\n        'value': innerPropValue\n      };\n      this.setCurrentProp(this.getPrevNode(), innerPropName);\n    }\n  });\n\n  // Parse an FBX file in Binary format\n  function BinaryParser() {}\n  Object.assign(BinaryParser.prototype, {\n    parse: function (buffer) {\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32();\n      console.log('THREE.FBXLoader: FBX binary version: ' + version);\n      var allNodes = new FBXTree();\n      while (!this.endOfContent(reader)) {\n        var node = this.parseNode(reader, version);\n        if (node !== null) allNodes.add(node.name, node);\n      }\n      return allNodes;\n    },\n    // Check if reader has reached the end of content.\n    endOfContent: function (reader) {\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //\t(seems like some exporters embed fixed 15 or 16bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n      } else {\n        return reader.getOffset() + 160 + 16 >= reader.size();\n      }\n    },\n    // recursively parse nodes until the end of the file is reached\n    parseNode: function (reader, version) {\n      var node = {};\n\n      // The first three data sizes depends on version.\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n      // note: do not remove this even if you get a linter warning as it moves the buffer forward\n      var propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen);\n\n      // Regards this node as NULL-record if endOffset is zero\n      if (endOffset === 0) return null;\n      var propertyList = [];\n      for (var i = 0; i < numProperties; i++) {\n        propertyList.push(this.parseProperty(reader));\n      }\n\n      // Regards the first three elements in propertyList as id, attrName, and attrType\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n      // check if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n      while (endOffset > reader.getOffset()) {\n        var subNode = this.parseNode(reader, version);\n        if (subNode !== null) this.parseSubNode(name, node, subNode);\n      }\n      node.propertyList = propertyList; // raw property list used by parent\n\n      if (typeof id === 'number') node.id = id;\n      if (attrName !== '') node.attrName = attrName;\n      if (attrType !== '') node.attrType = attrType;\n      if (name !== '') node.name = name;\n      return node;\n    },\n    parseSubNode: function (name, node, subNode) {\n      // special case: child node is single property\n      if (subNode.singleProperty === true) {\n        var value = subNode.propertyList[0];\n        if (Array.isArray(value)) {\n          node[subNode.name] = subNode;\n          subNode.a = value;\n        } else {\n          node[subNode.name] = value;\n        }\n      } else if (name === 'Connections' && subNode.name === 'C') {\n        var array = [];\n        subNode.propertyList.forEach(function (property, i) {\n          // first Connection is FBX type (OO, OP, etc.). We'll discard these\n          if (i !== 0) array.push(property);\n        });\n        if (node.connections === undefined) {\n          node.connections = [];\n        }\n        node.connections.push(array);\n      } else if (subNode.name === 'Properties70') {\n        var keys = Object.keys(subNode);\n        keys.forEach(function (key) {\n          node[key] = subNode[key];\n        });\n      } else if (name === 'Properties70' && subNode.name === 'P') {\n        var innerPropName = subNode.propertyList[0];\n        var innerPropType1 = subNode.propertyList[1];\n        var innerPropType2 = subNode.propertyList[2];\n        var innerPropFlag = subNode.propertyList[3];\n        var innerPropValue;\n        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n        } else {\n          innerPropValue = subNode.propertyList[4];\n        }\n\n        // this will be copied to parent, see above\n        node[innerPropName] = {\n          'type': innerPropType1,\n          'type2': innerPropType2,\n          'flag': innerPropFlag,\n          'value': innerPropValue\n        };\n      } else if (node[subNode.name] === undefined) {\n        if (typeof subNode.id === 'number') {\n          node[subNode.name] = {};\n          node[subNode.name][subNode.id] = subNode;\n        } else {\n          node[subNode.name] = subNode;\n        }\n      } else {\n        if (subNode.name === 'PoseNode') {\n          if (!Array.isArray(node[subNode.name])) {\n            node[subNode.name] = [node[subNode.name]];\n          }\n          node[subNode.name].push(subNode);\n        } else if (node[subNode.name][subNode.id] === undefined) {\n          node[subNode.name][subNode.id] = subNode;\n        }\n      }\n    },\n    parseProperty: function (reader) {\n      var type = reader.getString(1);\n      switch (type) {\n        case 'C':\n          return reader.getBoolean();\n        case 'D':\n          return reader.getFloat64();\n        case 'F':\n          return reader.getFloat32();\n        case 'I':\n          return reader.getInt32();\n        case 'L':\n          return reader.getInt64();\n        case 'R':\n          var length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n        case 'S':\n          var length = reader.getUint32();\n          return reader.getString(length);\n        case 'Y':\n          return reader.getInt16();\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'f':\n        case 'i':\n        case 'l':\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n          var compressedLength = reader.getUint32();\n          if (encoding === 0) {\n            switch (type) {\n              case 'b':\n              case 'c':\n                return reader.getBooleanArray(arrayLength);\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n            }\n          }\n          var inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n          var reader2 = new BinaryReader(inflate.decompress().buffer);\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader2.getBooleanArray(arrayLength);\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n          }\n        default:\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n      }\n    }\n  });\n  function BinaryReader(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n  Object.assign(BinaryReader.prototype, {\n    getOffset: function () {\n      return this.offset;\n    },\n    size: function () {\n      return this.dv.buffer.byteLength;\n    },\n    skip: function (length) {\n      this.offset += length;\n    },\n    // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean: function () {\n      return (this.getUint8() & 1) === 1;\n    },\n    getBooleanArray: function (size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getBoolean());\n      }\n      return a;\n    },\n    getUint8: function () {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    },\n    getInt16: function () {\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    },\n    getInt32: function () {\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getInt32Array: function (size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt32());\n      }\n      return a;\n    },\n    getUint32: function () {\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64: function () {\n      var low, high;\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n\n      // calculate negative value\n      if (high & 0x80000000) {\n        high = ~high & 0xFFFFFFFF;\n        low = ~low & 0xFFFFFFFF;\n        if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n        low = low + 1 & 0xFFFFFFFF;\n        return -(high * 0x100000000 + low);\n      }\n      return high * 0x100000000 + low;\n    },\n    getInt64Array: function (size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt64());\n      }\n      return a;\n    },\n    // Note: see getInt64() comment\n    getUint64: function () {\n      var low, high;\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n      return high * 0x100000000 + low;\n    },\n    getFloat32: function () {\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getFloat32Array: function (size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n      return a;\n    },\n    getFloat64: function () {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    },\n    getFloat64Array: function (size) {\n      var a = [];\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n      return a;\n    },\n    getArrayBuffer: function (size) {\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n    },\n    getString: function (size) {\n      var a = new Uint8Array(size);\n      for (var i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n      var nullByte = a.indexOf(0);\n      if (nullByte >= 0) a = a.slice(0, nullByte);\n      return THREE.LoaderUtils.decodeText(a);\n    }\n  });\n\n  // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n  // and BinaryParser( FBX Binary format)\n  function FBXTree() {}\n  Object.assign(FBXTree.prototype, {\n    add: function (key, val) {\n      this[key] = val;\n    }\n  });\n  function isFbxFormatBinary(buffer) {\n    var CORRECT = 'Kaydara FBX Binary  \\0';\n    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n  }\n  function isFbxFormatASCII(text) {\n    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n    var cursor = 0;\n    function read(offset) {\n      var result = text[offset - 1];\n      text = text.slice(cursor + offset);\n      cursor++;\n      return result;\n    }\n    for (var i = 0; i < CORRECT.length; ++i) {\n      var num = read(1);\n      if (num === CORRECT[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function getFbxVersion(text) {\n    var versionRegExp = /FBXVersion: (\\d+)/;\n    var match = text.match(versionRegExp);\n    if (match) {\n      var version = parseInt(match[1]);\n      return version;\n    }\n    throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n  }\n\n  // Converts FBX ticks into real time seconds.\n  function convertFBXTimeToSeconds(time) {\n    return time / 46186158000;\n  }\n\n  // Parses comma separated list of numbers and returns them an array.\n  // Used internally by the TextParser\n  function parseNumberArray(value) {\n    var array = value.split(',').map(function (val) {\n      return parseFloat(val);\n    });\n    return array;\n  }\n  function convertArrayBufferToString(buffer, from, to) {\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n    return THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n  }\n  function append(a, b) {\n    for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n      a[j] = b[i];\n    }\n  }\n  function slice(a, b, from, to) {\n    for (var i = from, j = 0; i < to; i++, j++) {\n      a[j] = b[i];\n    }\n    return a;\n  }\n\n  // inject array a2 into array a1 at index\n  function inject(a1, index, a2) {\n    return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n  }\n  return THREE.FBXLoader;\n}();","map":{"version":3,"names":["THREE","require","Zlib","module","exports","FBXLoader","manager","undefined","DefaultLoadingManager","Object","assign","prototype","load","url","onLoad","onProgress","onError","self","resourceDirectory","LoaderUtils","extractUrlBase","loader","FileLoader","setResponseType","buffer","scene","parse","error","window","setTimeout","itemError","FBXBuffer","FBXTree","isFbxFormatBinary","BinaryParser","FBXText","convertArrayBufferToString","isFbxFormatASCII","Error","getFbxVersion","TextParser","connections","parseConnections","images","parseImages","textures","parseTextures","TextureLoader","setPath","materials","parseMaterials","deformers","parseDeformers","geometryMap","parseGeometries","sceneGraph","parseScene","skeletons","connectionMap","Map","rawConnections","Connections","forEach","rawConnection","fromID","toID","relationship","has","set","parents","children","parentRelationship","ID","get","push","childRelationship","blobs","Objects","videoNodes","Video","nodeID","videoNode","id","parseInt","RelativeFilename","Filename","arrayBufferContent","Content","ArrayBuffer","byteLength","base64Content","image","parseImage","filename","split","pop","content","fileName","extension","slice","lastIndexOf","toLowerCase","type","TGALoader","console","warn","Loader","Handlers","add","array","Uint8Array","URL","createObjectURL","Blob","textureMap","textureNodes","Texture","texture","parseTexture","textureNode","loadTexture","name","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","value","valueV","wrapS","RepeatWrapping","ClampToEdgeWrapping","wrapT","values","Scaling","repeat","x","y","currentPath","path","length","indexOf","FileName","materialMap","materialNodes","Material","material","parseMaterial","materialNode","ShadingModel","parameters","parseParameters","MeshPhongMaterial","MeshLambertMaterial","color","setValues","properties","BumpFactor","bumpScale","Diffuse","Color","fromArray","DiffuseColor","DisplacementFactor","displacementScale","Emissive","emissive","EmissiveColor","EmissiveFactor","emissiveIntensity","parseFloat","Opacity","opacity","transparent","ReflectionFactor","reflectivity","Shininess","shininess","Specular","specular","SpecularColor","child","bumpMap","map","getTexture","displacementMap","emissiveMap","normalMap","envMap","mapping","EquirectangularReflectionMapping","specularMap","alphaMap","LayeredTexture","morphTargets","DeformerNodes","Deformer","deformerNode","relationships","attrType","skeleton","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","parentGeoID","deformerNodes","rawBones","boneNode","rawBone","indices","weights","transform","Matrix4","Transform","a","transformLink","TransformLink","linkMode","Mode","Indexes","Weights","bones","rawMorphTargets","i","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","targetRelationships","weightCurveID","geoID","geoNodes","Geometry","geo","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","modelNodes","parent","Model","reduce","preTransform","modelNode","GeometricRotation","Math","degToRad","makeRotationFromEuler","Euler","setPosition","Vector3","GeometricTranslation","scale","GeometricScaling","genGeometry","BufferGeometry","geoInfo","getGeoInfo","buffers","genBuffers","positionAttribute","Float32BufferAttribute","vertex","applyToBufferAttribute","addAttribute","colors","Uint16BufferAttribute","weightsIndices","vertexWeights","FBX_Deformer","normal","normalAttribute","normalMatrix","Matrix3","getNormalMatrix","uvs","uvBuffer","toString","mappingType","prevMaterialIndex","materialIndex","startIndex","currentIndex","addGroup","groups","lastGroup","lastIndex","start","count","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","getColors","LayerElementMaterial","getMaterials","LayerElementNormal","getNormals","LayerElementUV","uv","getUVs","weightTable","index","j","weight","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","data","getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","genFace","parentGeo","parentGeoNode","morphAttributes","position","rawTarget","morphGeoNode","genMorphGeometry","morphGeo","morphPositions","morphIndex","morphGeoInfo","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UV","UVIndex","ColorNode","Colors","ColorIndex","MaterialNode","materialIndexBuffer","Materials","materialIndices","dataArray","infoObject","from","to","NURBSCurve","order","Order","isNaN","degree","knots","KnotVector","controlPoints","pointsValues","Points","l","Vector4","startKnot","endKnot","Form","curve","vertices","getPoints","positions","Float32Array","toArray","geometry","BufferAttribute","Group","modelMap","parseModels","model","setLookAtProperties","parentConnections","connection","bindSkeleton","addAnimations","createAmbientLight","node","buildSkeleton","createCamera","createLight","createMesh","createCurve","PropertyBinding","sanitizeNodeName","setModelTransforms","bone","subBone","Bone","matrixWorld","copy","cameraAttribute","attr","NodeAttribute","Object3D","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","width","innerWidth","height","innerHeight","AspectWidth","AspectHeight","aspect","fov","FieldOfView","focalLength","FocalLength","PerspectiveCamera","setFocalLength","OrthographicCamera","lightAttribute","LightType","intensity","Intensity","CastLightOnObject","distance","FarAttenuationEnd","EnableFarAttenuation","decay","PointLight","DirectionalLight","angle","PI","InnerAngle","penumbra","OuterAngle","max","SpotLight","CastShadows","castShadow","attributes","vertexColors","VertexColors","skinning","SkinnedMesh","Mesh","LineBasicMaterial","linewidth","Line","GlobalSettings","ambientColor","AmbientColor","r","g","b","AmbientLight","lookAtTarget","pos","Lcl_Translation","target","lookAt","enums","RotationOrder","rotation","Lcl_Rotation","quaternion","setFromEuler","Lcl_Scaling","PreRotation","preRotations","Quaternion","premultiply","bindMatrices","parsePoseNodes","geoRelationships","geoConnParent","bind","Skeleton","BindPoseNode","Pose","poseNodes","PoseNode","Array","isArray","poseNode","Node","Matrix","parseAnimations","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","rawClips","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","match","curveNode","curves","rawCurves","animationCurve","times","KeyTime","convertFBXTimeToSeconds","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","z","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","rawStacks","AnimationStack","layer","animations","key","rawClip","clip","addClip","tracks","rawTracks","concat","generateTracks","AnimationClip","T","keys","positionTrack","generateVectorTrack","R","rotationTrack","generateRotationTrack","S","scaleTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","VectorKeyframeTrack","interpolateRotations","euler","quaternionValues","QuaternionKeyframeTrack","prevValue","xIndex","yIndex","zIndex","time","xValue","yValue","zValue","sort","filter","elem","valuesSpan","absoluteSpan","abs","numSubIntervals","step","nextValue","initialTime","timeSpan","interval","nextTime","interpolatedTimes","interpolatedValues","inject","getPrevNode","nodeStack","currentIndent","getCurrentNode","getCurrentProp","currentProp","pushStack","popStack","setCurrentProp","val","currentPropName","text","allNodes","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","parseNodePropertyContinued","property","nodeName","trim","replace","nodeAttrs","attrs","parseNodeAttr","currentNode","contentLine","propName","propValue","parentName","parseNodeSpecialProperty","connProps","rest","append","parseNumberArray","props","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","reader","BinaryReader","skip","version","getUint32","log","endOfContent","parseNode","size","getOffset","endOffset","getUint64","numProperties","propertyListLen","nameLen","getUint8","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getFloat64","getFloat32","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","encoding","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","inflate","Inflate","reader2","decompress","littleEndian","dv","DataView","offset","low","high","nullByte","decodeText","CORRECT","cursor","read","result","num","versionRegExp","a1","a2"],"sources":["/Users/jens/my-app/node_modules/three-fbxloader-offical/index.js"],"sourcesContent":["const THREE = require('three');\nvar Zlib = require('./inflate.min').Zlib;\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nmodule.exports = ( function () {\n\n\tTHREE.FBXLoader = function ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t};\n\n\tObject.assign( THREE.FBXLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar resourceDirectory = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar scene = self.parse( buffer, resourceDirectory );\n\t\t\t\t\tonLoad( scene );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\twindow.setTimeout( function () {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tself.manager.itemError( url );\n\n\t\t\t\t\t}, 0 );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, resourceDirectory ) {\n\n\t\t\tvar FBXTree;\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tFBXTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tFBXTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( FBXTree );\n\n\t\t\tvar connections = parseConnections( FBXTree );\n\t\t\tvar images = parseImages( FBXTree );\n\t\t\tvar textures = parseTextures( FBXTree, new THREE.TextureLoader( this.manager ).setPath( resourceDirectory ), images, connections );\n\t\t\tvar materials = parseMaterials( FBXTree, textures, connections );\n\t\t\tvar deformers = parseDeformers( FBXTree, connections );\n\t\t\tvar geometryMap = parseGeometries( FBXTree, connections, deformers );\n\t\t\tvar sceneGraph = parseScene( FBXTree, connections, deformers.skeletons, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t}\n\n\t} );\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tfunction parseConnections( FBXTree ) {\n\n\t\tvar connectionMap = new Map();\n\n\t\tif ( 'Connections' in FBXTree ) {\n\n\t\t\tvar rawConnections = FBXTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tfunction parseImages( FBXTree ) {\n\n\t\tvar images = {};\n\t\tvar blobs = {};\n\n\t\tif ( 'Video' in FBXTree.Objects ) {\n\n\t\t\tvar videoNodes = FBXTree.Objects.Video;\n\n\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tvar image = parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var id in images ) {\n\n\t\t\tvar filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tfunction parseImage( videoNode ) {\n\n\t\tvar content = videoNode.Content;\n\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tvar type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n \t\t\tcase 'tga':\n\n\t\t\t\tif ( typeof THREE.TGALoader !== 'function' ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: THREE.TGALoader is required to load TGA textures' );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( THREE.Loader.Handlers.get( '.tga' ) === null ) {\n\n\t\t\t\t\t\tTHREE.Loader.Handlers.add( /\\.tga$/i, new THREE.TGALoader() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tvar array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tfunction parseTextures( FBXTree, loader, images, connections ) {\n\n\t\tvar textureMap = new Map();\n\n\t\tif ( 'Texture' in FBXTree.Objects ) {\n\n\t\t\tvar textureNodes = FBXTree.Objects.Texture;\n\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\tvar texture = parseTexture( textureNodes[ nodeID ], loader, images, connections );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tfunction parseTexture( textureNode, loader, images, connections ) {\n\n\t\tvar texture = loadTexture( textureNode, loader, images, connections );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\tfunction loadTexture( textureNode, loader, images, connections ) {\n\n\t\tvar fileName;\n\n\t\tvar currentPath = loader.path;\n\n\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tloader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar texture;\n\n\t\tif ( textureNode.FileName.slice( -3 ).toLowerCase() === 'tga' ) {\n\n \t\t\ttexture = THREE.Loader.Handlers.get( '.tga' ).load( fileName );\n\n \t\t} else {\n\n \t\t\ttexture = loader.load( fileName );\n\n \t\t}\n\n\t\tloader.setPath( currentPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tfunction parseMaterials( FBXTree, textureMap, connections ) {\n\n\t\tvar materialMap = new Map();\n\n\t\tif ( 'Material' in FBXTree.Objects ) {\n\n\t\t\tvar materialNodes = FBXTree.Objects.Material;\n\n\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\tvar material = parseMaterial( FBXTree, materialNodes[ nodeID ], textureMap, connections );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tfunction parseMaterial( FBXTree, materialNode, textureMap, connections ) {\n\n\t\tvar ID = materialNode.id;\n\t\tvar name = materialNode.attrName;\n\t\tvar type = materialNode.ShadingModel;\n\n\t\t//Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tvar parameters = parseParameters( FBXTree, materialNode, textureMap, ID, connections );\n\n\t\tvar material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0x3300ff } );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tfunction parseParameters( FBXTree, properties, textureMap, ID, connections ) {\n\n\t\tvar parameters = {};\n\n\t\tif ( properties.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\n\t\t}\n\t\tif ( properties.Diffuse ) {\n\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.Diffuse.value );\n\n\t\t} else if ( properties.DiffuseColor && properties.DiffuseColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in properties.Diffuse\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.DiffuseColor.value );\n\n\t\t}\n\t\tif ( properties.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\n\t\t}\n\t\tif ( properties.Emissive ) {\n\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.Emissive.value );\n\n\t\t} else if ( properties.EmissiveColor && properties.EmissiveColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in properties.Emissive\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.EmissiveColor.value );\n\n\t\t}\n\t\tif ( properties.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( properties.EmissiveFactor.value );\n\n\t\t}\n\t\tif ( properties.Opacity ) {\n\n\t\t\tparameters.opacity = parseFloat( properties.Opacity.value );\n\n\t\t}\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\t\tif ( properties.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\n\t\t}\n\t\tif ( properties.Shininess ) {\n\n\t\t\tparameters.shininess = properties.Shininess.value;\n\n\t\t}\n\t\tif ( properties.Specular ) {\n\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.Specular.value );\n\n\t\t} else if ( properties.SpecularColor && properties.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in properties.Specular\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.SpecularColor.value );\n\n\t\t}\n\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tvar type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = textureMap.get( child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tparameters.map = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tparameters.normalMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tparameters.alphaMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tfunction getTexture( FBXTree, textureMap, id, connections ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tfunction parseDeformers( FBXTree, connections ) {\n\n\t\tvar skeletons = {};\n\t\tvar morphTargets = {};\n\n\t\tif ( 'Deformer' in FBXTree.Objects ) {\n\n\t\t\tvar DeformerNodes = FBXTree.Objects.Deformer;\n\n\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tvar skeleton = parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = parseMorphTargets( relationships, deformerNode, DeformerNodes, connections, FBXTree );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\t\t\t\t\tmorphTarget.parentGeoID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tfunction parseSkeleton( connections, deformerNodes ) {\n\n\t\tvar rawBones = [];\n\n\t\tconnections.children.forEach( function ( child ) {\n\n\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tvar rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\ttransformLink: new THREE.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\tlinkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tfunction parseMorphTargets( relationships, deformerNode, deformerNodes, connections ) {\n\n\t\tvar rawMorphTargets = [];\n\n\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tif ( i === 8 ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.' );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar child = relationships.children[ i ];\n\n\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tvar rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\tvar targetRelationships = connections.get( parseInt( child.ID ) );\n\n\t\t\ttargetRelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'DeformPercent' ) {\n\n\t\t\t\t\t// TODO: animation of morph targets is currently unsupported\n\t\t\t\t\trawMorphTarget.weightCurveID = child.ID;\n\t\t\t\t\t// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\trawMorphTarget.geoID = child.ID;\n\t\t\t\t\t// morphGeo = FBXTree.Objects.Geometry[ geoID ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tfunction parseGeometries( FBXTree, connections, deformers ) {\n\n\t\tvar geometryMap = new Map();\n\n\t\tif ( 'Geometry' in FBXTree.Objects ) {\n\n\t\t\tvar geoNodes = FBXTree.Objects.Geometry;\n\n\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tvar geo = parseGeometry( FBXTree, relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tfunction parseGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn parseMeshGeometry( FBXTree, relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tfunction parseMeshGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tvar skeletons = deformers.skeletons;\n\t\tvar morphTargets = deformers.morphTargets;\n\n\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn FBXTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\tvar morphTarget = relationships.children.reduce( function ( morphTarget, child ) {\n\n\t\t\tif ( morphTargets[ child.ID ] !== undefined ) morphTarget = morphTargets[ child.ID ];\n\n\t\t\treturn morphTarget;\n\n\t\t}, null );\n\n\t\tvar preTransform = new THREE.Matrix4();\n\n\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\n\t\t// different geometric transforms, then this will cause problems\n\t\t// if ( modelNodes.length > 1 ) { }\n\n\t\t// For now just assume one model and get the preRotations from that\n\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\tif ( 'GeometricRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.GeometricRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tpreTransform.makeRotationFromEuler( new THREE.Euler().fromArray( array ) );\n\n\t\t}\n\n\t\tif ( 'GeometricTranslation' in modelNode ) {\n\n\t\t\tpreTransform.setPosition( new THREE.Vector3().fromArray( modelNode.GeometricTranslation.value ) );\n\n\t\t}\n\n\t\tif ( 'GeometricScaling' in modelNode ) {\n\n\t\t\tpreTransform.scale( new THREE.Vector3().fromArray( modelNode.GeometricScaling.value ) );\n\n\t\t}\n\n\t\treturn genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform );\n\n\t}\n\n\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\tfunction genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform ) {\n\n\t\tvar geo = new THREE.BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tvar geoInfo = getGeoInfo( geoNode, skeleton );\n\n\t\tvar buffers = genBuffers( geoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tgeo.addAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.addAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.addAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n\t\t\tnormalMatrix.applyToBufferAttribute( normalAttribute );\n\n\t\t\tgeo.addAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tname = 'uv';\n\n\t\t\t}\n\n\t\t\tgeo.addAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tvar startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\taddMorphTargets( FBXTree, geo, geoNode, morphTarget, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tfunction getGeoInfo( geoNode, skeleton ) {\n\n\t\tvar geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = getColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = getMaterials( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = getNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tgeoInfo.uv.push( getUVs( geoNode.LayerElementUV[ i ] ) );\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tfunction genBuffers( geoInfo ) {\n\n\t\tvar buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tvar polygonIndex = 0;\n\t\tvar faceLength = 0;\n\t\tvar displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tvar facePositionIndexes = [];\n\t\tvar faceNormals = [];\n\t\tvar faceColors = [];\n\t\tvar faceUVs = [];\n\t\tvar faceWeights = [];\n\t\tvar faceWeightIndices = [];\n\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tvar endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tvar weightIndices = [];\n\t\t\tvar weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tfunction genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction addMorphTargets( FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform ) {\n\n\t\tif ( morphTarget === null ) return;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\tparentGeo.morphAttributes.normal = [];\n\n\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\tvar morphGeoNode = FBXTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tfunction genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform ) {\n\n\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\tif ( morphGeoNode.attrName ) morphGeo.name = morphGeoNode.attrName;\n\n\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t// make a copy of the parent's vertex positions\n\t\tvar vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\tvar morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\tvertexPositions[ morphIndex ] += morphPositions[ i * 3 ];\n\t\t\tvertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];\n\t\t\tvertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tvar morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: vertexPositions,\n\t\t};\n\n\t\tvar morphBuffers = genBuffers( morphGeoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = morphGeoNode.attrName;\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tfunction getNormals( NormalNode ) {\n\n\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\tvar buffer = NormalNode.Normals.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tfunction getUVs( UVNode ) {\n\n\t\tvar mappingType = UVNode.MappingInformationType;\n\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\tvar buffer = UVNode.UV.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tfunction getColors( ColorNode ) {\n\n\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\tvar buffer = ColorNode.Colors.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tfunction getMaterials( MaterialNode ) {\n\n\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tvar materialIndices = [];\n\n\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\tvar dataArray = [];\n\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tfunction parseNurbsGeometry( geoNode ) {\n\n\t\tif ( THREE.NURBSCurve === undefined ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar degree = order - 1;\n\n\t\tvar knots = geoNode.KnotVector.a;\n\t\tvar controlPoints = [];\n\t\tvar pointsValues = geoNode.Points.a;\n\n\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tvar startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t} );\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\t// create the main THREE.Group() to be returned by the loader\n\tfunction parseScene( FBXTree, connections, skeletons, geometryMap, materialMap ) {\n\n\t\tvar sceneGraph = new THREE.Group();\n\n\t\tvar modelMap = parseModels( FBXTree, skeletons, geometryMap, materialMap, connections );\n\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\tsetLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph );\n\n\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tbindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections );\n\n\t\taddAnimations( FBXTree, connections, sceneGraph );\n\n\t\tcreateAmbientLight( FBXTree, sceneGraph );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tfunction parseModels( FBXTree, skeletons, geometryMap, materialMap, connections ) {\n\n\t\tvar modelMap = new Map();\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\tvar id = parseInt( nodeID );\n\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\tvar relationships = connections.get( id );\n\n\t\t\tvar model = buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = createCamera( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = createLight( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = createMesh( FBXTree, relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName( node.attrName );\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tsetModelTransforms( FBXTree, model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tfunction buildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tvar bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName( name );\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\tfunction createCamera( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tvar nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tvar farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tvar width = window.innerWidth;\n\t\t\tvar height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tvar aspect = width / height;\n\n\t\t\tvar fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tmodel = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\tfunction createLight( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tvar color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = new THREE.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t}\n\n\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tvar distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tvar decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = THREE.Math.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = THREE.Math.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createMesh( FBXTree, relationships, geometryMap, materialMap ) {\n\n\t\tvar model;\n\t\tvar geometry = null;\n\t\tvar material = null;\n\t\tvar materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.skinning = true;\n\n\t\t\t} );\n\n\t\t\tmodel = new THREE.SkinnedMesh( geometry, material );\n\n\t\t} else {\n\n\t\t\tmodel = new THREE.Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createCurve( relationships, geometryMap ) {\n\n\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\treturn new THREE.Line( geometry, material );\n\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tfunction createAmbientLight( FBXTree, sceneGraph ) {\n\n\t\tif ( 'GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings ) {\n\n\t\t\tvar ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n\t\t\tvar r = ambientColor[ 0 ];\n\t\t\tvar g = ambientColor[ 1 ];\n\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\tvar color = new THREE.Color( r, g, b );\n\t\t\t\tsceneGraph.add( new THREE.AmbientLight( color, 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new THREE.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// parse the model node for transform details and apply them to the model\n\tfunction setModelTransforms( FBXTree, model, modelNode ) {\n\n\t\t// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tif ( 'RotationOrder' in modelNode ) {\n\n\t\t\tvar enums = [\n\t\t\t\t'XYZ', // default\n\t\t\t\t'XZY',\n\t\t\t\t'YZX',\n\t\t\t\t'ZXY',\n\t\t\t\t'YXZ',\n\t\t\t\t'ZYX',\n\t\t\t\t'SphericXYZ',\n\t\t\t];\n\n\t\t\tvar value = parseInt( modelNode.RotationOrder.value, 10 );\n\n\t\t\tif ( value > 0 && value < 6 ) {\n\n\t\t\t\t// model.rotation.order = enums[ value ];\n\n\t\t\t\t// Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[ value ] );\n\n\t\t\t} else if ( value === 6 ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( 'Lcl_Translation' in modelNode ) {\n\n\t\t\tmodel.position.fromArray( modelNode.Lcl_Translation.value );\n\n\t\t}\n\n\t\tif ( 'Lcl_Rotation' in modelNode ) {\n\n\t\t\tvar rotation = modelNode.Lcl_Rotation.value.map( THREE.Math.degToRad );\n\t\t\trotation.push( 'ZYX' );\n\t\t\tmodel.quaternion.setFromEuler( new THREE.Euler().fromArray( rotation ) );\n\n\t\t}\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) {\n\n\t\t\tmodel.scale.fromArray( modelNode.Lcl_Scaling.value );\n\n\t\t}\n\n\t\tif ( 'PreRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.PreRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tvar preRotations = new THREE.Euler().fromArray( array );\n\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\t\t\tmodel.quaternion.premultiply( preRotations );\n\n\t\t}\n\n\t}\n\n\tfunction bindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections ) {\n\n\t\tvar bindMatrices = parsePoseNodes( FBXTree );\n\n\t\tfor ( var ID in skeletons ) {\n\n\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new THREE.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tfunction parsePoseNodes( FBXTree ) {\n\n\t\tvar bindMatrices = {};\n\n\t\tif ( 'Pose' in FBXTree.Objects ) {\n\n\t\t\tvar BindPoseNode = FBXTree.Objects.Pose;\n\n\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\tfunction parseAnimations( FBXTree, connections ) {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( FBXTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tvar curveNodesMap = parseAnimationCurveNodes( FBXTree );\n\n\t\tparseAnimationCurves( FBXTree, connections, curveNodesMap );\n\n\t\tvar layersMap = parseAnimationLayers( FBXTree, connections, curveNodesMap );\n\t\tvar rawClips = parseAnimStacks( FBXTree, connections, layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tfunction parseAnimationCurveNodes( FBXTree ) {\n\n\t\tvar rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n\n\t\tvar curveNodesMap = new Map();\n\n\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T/ ) !== null ) {\n\n\t\t\t\tvar curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tfunction parseAnimationCurves( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawCurves = FBXTree.Objects.AnimationCurve;\n\n\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\tvar animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tfunction parseAnimationLayers( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawLayers = FBXTree.Objects.AnimationLayer;\n\n\t\tvar layersMap = new Map();\n\n\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\tvar layerCurveNodes = [];\n\n\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tvar children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tvar modelID;\n\n\t\t\t\t\t\t\t\tconnections.get( child.ID ).parents.forEach( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\tif ( parent.relationship !== undefined ) modelID = parent.ID;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\tvar rawModel = FBXTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ),\n\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Translation' in rawModel ) node.initialPosition = rawModel.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Rotation' in rawModel ) node.initialRotation = rawModel.Lcl_Rotation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Scaling' in rawModel ) node.initialScale = rawModel.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotations = rawModel.PreRotation.value;\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\tfunction parseAnimStacks( FBXTree, connections, layersMap ) {\n\n\t\tvar rawStacks = FBXTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tvar rawClips = {};\n\n\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\t// take raw animation data from parseAnimations and connect it up to the loaded models\n\tfunction addAnimations( FBXTree, connections, sceneGraph ) {\n\n\t\tsceneGraph.animations = [];\n\n\t\tvar rawClips = parseAnimations( FBXTree, connections );\n\n\t\tif ( rawClips === undefined ) return;\n\n\n\t\tfor ( var key in rawClips ) {\n\n\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\tvar clip = addClip( rawClip );\n\n\t\t\tsceneGraph.animations.push( clip );\n\n\t\t}\n\n\t}\n\n\tfunction addClip( rawClip ) {\n\n\t\tvar tracks = [];\n\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new THREE.AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tfunction generateTracks( rawTracks ) {\n\n\t\tvar tracks = [];\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tvar positionTrack = generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tvar rotationTrack = generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tvar scaleTrack = generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tfunction generateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new THREE.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tfunction generateRotationTrack( modelName, curves, initialValue, preRotations ) {\n\n\t\tif ( curves.x !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.x );\n\t\t\tcurves.x.values = curves.x.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.y !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.y );\n\t\t\tcurves.y.values = curves.y.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.z !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.z );\n\t\t\tcurves.z.values = curves.z.values.map( THREE.Math.degToRad );\n\n\t\t}\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\tif ( preRotations !== undefined ) {\n\n\t\t\tpreRotations = preRotations.map( THREE.Math.degToRad );\n\t\t\tpreRotations.push( 'ZYX' );\n\n\t\t\tpreRotations = new THREE.Euler().fromArray( preRotations );\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\n\t\t}\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar quaternionValues = [];\n\n\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], 'ZYX' );\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotations !== undefined )quaternion.premultiply( preRotations );\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new THREE.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tfunction getKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tvar prevValue = initialValue;\n\n\t\tvar values = [];\n\n\t\tvar xIndex = - 1;\n\t\tvar yIndex = - 1;\n\t\tvar zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tfunction getTimesForAllAxes( curves ) {\n\n\t\tvar times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them and remove duplicates\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} ).filter( function ( elem, index, array ) {\n\n\t\t\treturn array.indexOf( elem ) == index;\n\n\t\t} );\n\n\t\treturn times;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tfunction interpolateRotations( curve ) {\n\n\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\tnextValue += step;\n\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tObject.assign( TextParser.prototype, {\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar self = this;\n\n\t\t\tvar split = text.split( '\\n' );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tself.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tself.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t} );\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tObject.assign( BinaryParser.prototype, {\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tconsole.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tObject.assign( BinaryReader.prototype, {\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\tvar a = new Uint8Array( size );\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn THREE.LoaderUtils.decodeText( a );\n\n\t\t}\n\n\t} );\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tObject.assign( FBXTree.prototype, {\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t} );\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn THREE.FBXLoader\n\n} )();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}